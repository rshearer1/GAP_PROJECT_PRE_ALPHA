--[[
    DataService.lua
    Server-side data persistence
    
    Handles:
    - Saving player data to DataStore
    - Loading player data on join
    - Auto-save system
    - Data validation and migration
    
    GAP Compliance:
    - Uses Janitor for cleanup
    - References Constants for configuration
    - JSDoc comments on all public methods
]]

local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
local Janitor = require(game:GetService("ReplicatedStorage").Packages.Janitor)
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Constants = require(ReplicatedStorage.Shared.Constants)

local DataService = Knit.CreateService {
    Name = "DataService",
    
    -- DataStore
    _playerDataStore = nil,
    
    -- Cache player data in memory
    _playerData = {},
    
    -- Janitor for cleanup
    _janitor = Janitor.new(),
}

-- Default player data template
---
-- Get default player data structure
-- @param userId number - The user ID
-- @return table - Default player data template
--
local function getDefaultData(userId: number)
    return {
        userId = userId,
        planet = {
            userId = userId,
            level = 1,
            experience = 0,
            biome = "Barren",
            size = 10,
            temperature = 0,
            atmosphere = 0,
            resources = {
                water = 0,
                minerals = 0,
                energy = 0,
                biomass = 0,
            },
            lastUpdated = os.time(),
        },
        solarSystem = nil, -- Will be generated by SolarSystemService
        upgrades = {}, -- { [upgradeId] = level }
        progression = {
            biomesCompleted = {},
            achievements = {},
            rebirthCount = 0,
            rebirthMultiplier = 0,
            starUpgrades = {},
        },
        stats = {
            totalPlayTime = 0,
            sessionStartTime = os.time(),
        },
        settings = {},
        dataVersion = 1,
    }
end

---
-- Initialize DataService
-- Connects to DataStore or warns if unavailable
--
function DataService:KnitInit()
    print("[DataService] Initializing...")
    
    -- Get DataStore
    local success, result = pcall(function()
        return DataStoreService:GetDataStore("PlayerData_v1")
    end)
    
    if success then
        self._playerDataStore = result
        print("[DataService] DataStore connected successfully")
    else
        warn("[DataService] Failed to connect to DataStore:", result)
        warn("[DataService] Data will NOT be saved!")
    end
end

---
-- Start DataService
-- Begins auto-save loop and binds to game close event
-- Uses Constants.GAMEPLAY.AUTO_SAVE_INTERVAL for timing
--
function DataService:KnitStart()
    print("[DataService] Starting...")
    
    -- Auto-save loop (managed by Janitor)
    self._janitor:Add(task.spawn(function()
        while true do
            task.wait(Constants.GAMEPLAY.AUTO_SAVE_INTERVAL)
            self:SaveAllPlayers()
        end
    end), "task.cancel")
    
    -- Save all players on game shutdown
    game:BindToClose(function()
        print("[DataService] Game closing, saving all player data...")
        self:SaveAllPlayers()
        task.wait(3) -- Give time for saves to complete
    end)
    
    print("[DataService] Started! Auto-save interval:", Constants.GAMEPLAY.AUTO_SAVE_INTERVAL, "seconds")
end

---
-- Load player data from DataStore or return defaults
-- Merges saved data with default structure to handle new fields
-- @param player Player - The player to load data for
-- @return table - The loaded or default player data
--
-- Load player data
function DataService:LoadPlayerData(player: Player)
end

-- Load player data
function DataService:LoadPlayerData(player: Player)
    if not self._playerDataStore then
        warn("[DataService] DataStore not available, using default data")
        local defaultData = getDefaultData(player.UserId)
        self._playerData[player.UserId] = defaultData
        return defaultData
    end
    
    local success, data = pcall(function()
        return self._playerDataStore:GetAsync("Player_" .. player.UserId)
    end)
    
    if success then
        if data then
            print("[DataService] Loaded data for", player.Name)
            -- Merge with default data to handle new fields
            local defaultData = getDefaultData(player.UserId)
            for key, value in pairs(data) do
                defaultData[key] = value
            end
            self._playerData[player.UserId] = defaultData
            return defaultData
        else
            print("[DataService] No saved data for", player.Name, "- using defaults")
            local defaultData = getDefaultData(player.UserId)
            self._playerData[player.UserId] = defaultData
            return defaultData
        end
    else
        warn("[DataService] Failed to load data for", player.Name, ":", data)
        local defaultData = getDefaultData(player.UserId)
        self._playerData[player.UserId] = defaultData
        return defaultData
    end
end

---
-- Save player data to DataStore
-- Updates play time statistics before saving
-- @param player Player - The player to save data for
-- @return boolean - True if save succeeded, false otherwise
--
-- Save player data
function DataService:SavePlayerData(player: Player)
    local userId = player.UserId
    local data = self._playerData[userId]
    
    if not data then
        warn("[DataService] No data to save for", player.Name)
        return false
    end
    
    if not self._playerDataStore then
        warn("[DataService] DataStore not available, cannot save")
        return false
    end
    
    -- Update play time
    if data.stats and data.stats.sessionStartTime then
        local sessionTime = os.time() - data.stats.sessionStartTime
        data.stats.totalPlayTime = (data.stats.totalPlayTime or 0) + sessionTime
        data.stats.sessionStartTime = os.time()
    end
    
    local success, errorMsg = pcall(function()
        self._playerDataStore:SetAsync("Player_" .. userId, data)
    end)
    
    if success then
        print("[DataService] Saved data for", player.Name)
        return true
    else
        warn("[DataService] Failed to save data for", player.Name, ":", errorMsg)
        return false
    end
end

---
-- Save all active players' data
-- Called by auto-save loop and on game shutdown
-- @return number - Count of successfully saved players
--
-- Save all players
function DataService:SaveAllPlayers()
    print("[DataService] Auto-saving all players...")
    local count = 0
    
    for userId, data in pairs(self._playerData) do
        local player = Players:GetPlayerByUserId(userId)
        if player then
            if self:SavePlayerData(player) then
                count = count + 1
            end
        end
    end
    
    print("[DataService] Auto-save complete. Saved", count, "players")
end

---
-- Get player data from cache
-- @param userId number - The user ID
-- @return table? - The cached player data or nil
--
-- Get player data from cache
function DataService:GetPlayerData(userId: number)
    return self._playerData[userId]
end

---
-- Update player data in cache
-- @param userId number - The user ID
-- @param dataUpdates table - Key-value pairs to update
-- @return boolean - True if update succeeded, false if player not loaded
--
-- Update player data in cache
function DataService:UpdatePlayerData(userId: number, dataUpdates)
    if not self._playerData[userId] then
        warn("[DataService] Cannot update data for user", userId, "- not loaded")
        return false
    end
    
    for key, value in pairs(dataUpdates) do
        self._playerData[userId][key] = value
    end
    
    return true
end

---
-- Remove player data from cache when they leave
-- @param userId number - The user ID to unload
--
-- Remove player from cache (when they leave)
function DataService:UnloadPlayerData(userId: number)
    self._playerData[userId] = nil
end

return DataService
