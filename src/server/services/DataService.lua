--[[--[[

    DataService.lua    DataService.lua

    Server-side data persistence using ProfileService    Server-side data persistence with session-locking

        

    Handles:    Handles:

    - Loading/releasing player profiles with ProfileService    - Saving/loading player data with DataStore

    - Auto-save system (ProfileService handles this automatically)    - Auto-save system with retry logic

    - Session-locking (ProfileService handles this automatically)    - Session-locking to prevent data duplication

    - Data validation and migration via :Reconcile()    - Data validation and migration

    - Graceful shutdown and player leave handling    - Graceful shutdown handling

    - GDPR compliance via :AddUserId()    - Error recovery and backup systems

        

    GAP Compliance:    GAP Compliance:

    - Uses Janitor for cleanup    - Uses Janitor for cleanup

    - References Constants for configuration    - References Constants for configuration

    - JSDoc comments on all public methods    - JSDoc comments on all public methods

        - Implements session-locking pattern

    ProfileService Benefits:    

    - Automatic session-locking (prevents duplication)    Session-Locking Pattern:

    - Auto-save every 30 seconds    - Uses UpdateAsync for atomic session claim

    - :Reconcile() fills missing fields from template    - Stores sessionId in DataStore

    - :ListenToRelease() handles profile stealing    - Releases session on player leave

]]    - Prevents multiple servers loading same profile

]]

local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)

local Janitor = require(game:GetService("ReplicatedStorage").Packages.Janitor)local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)

local ProfileService = require(script.Parent.Parent.ProfileService)local Janitor = require(game:GetService("ReplicatedStorage").Packages.Janitor)

local Players = game:GetService("Players")local DataStoreService = game:GetService("DataStoreService")

local ReplicatedStorage = game:GetService("ReplicatedStorage")local Players = game:GetService("Players")

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Constants = require(ReplicatedStorage.Shared.Constants)local HttpService = game:GetService("HttpService")

local RunService = game:GetService("RunService")

local DataService = Knit.CreateService {

    Name = "DataService",local Constants = require(ReplicatedStorage.Shared.Constants)

    

    -- ProfileStore instancelocal DataService = Knit.CreateService {

    _profileStore = nil,    Name = "DataService",

        

    -- Active profiles { [player] = profile }    -- DataStore

    _profiles = {},    _playerDataStore = nil,

        

    -- Janitor for cleanup    -- Cache player data in memory

    _janitor = Janitor.new(),    _playerData = {},

}    

    -- Active sessions (prevents concurrent access)

-- Data version for migration tracking    _activeSessions = {},

local DATA_VERSION = 2    

    -- Session IDs for tracking

-- ProfileTemplate - what empty profiles will default to    _sessionIds = {},

-- ProfileService will auto-fill missing fields with :Reconcile()    

local ProfileTemplate = {    -- Retry configuration

    userId = 0,    _maxRetries = 3,

        _retryDelay = 1,

    planet = {    

        userId = 0,    -- Janitor for cleanup

        level = 1,    _janitor = Janitor.new(),

        experience = 0,    

        biome = "Barren",    -- Shutdown flag

        size = 10,    _isShuttingDown = false,

        temperature = 0,}

        atmosphere = 0,

        resources = {-- Data version for migration tracking

            water = 0,local DATA_VERSION = 2

            minerals = 0,

            energy = 0,-- Default player data template

            biomass = 0,---

        },-- Get default player data structure

        lastUpdated = os.time(),-- @param userId number - The user ID

    },-- @return table - Default player data template

    --

    solarSystem = nil, -- Will be generated by SolarSystemServicelocal function getDefaultData(userId: number)

        return {

    upgrades = {}, -- { [upgradeId] = level }        userId = userId,

            planet = {

    pets = {}, -- Array of pet data            userId = userId,

                level = 1,

    progression = {            experience = 0,

        biomesCompleted = {},            biome = "Barren",

        achievements = {},            size = 10,

        rebirthCount = 0,            temperature = 0,

        rebirthMultiplier = 0,            atmosphere = 0,

        starUpgrades = {},            resources = {

    },                water = 0,

                    minerals = 0,

    stats = {                energy = 0,

        totalPlayTime = 0,                biomass = 0,

        sessionStartTime = os.time(),            },

        petsHatched = 0,            lastUpdated = os.time(),

        lastLogin = os.time(),        },

        loginCount = 0,        solarSystem = nil, -- Will be generated by SolarSystemService

    },        upgrades = {}, -- { [upgradeId] = level }

            pets = {}, -- Array of pet data

    settings = {},        progression = {

                biomesCompleted = {},

    -- Metadata            achievements = {},

    dataVersion = DATA_VERSION,            rebirthCount = 0,

    createdAt = os.time(),            rebirthMultiplier = 0,

    lastSaved = os.time(),            starUpgrades = {},

}        },

        stats = {

---            totalPlayTime = 0,

-- Initialize DataService            sessionStartTime = os.time(),

-- Creates ProfileStore instance            petsHatched = 0,

--            lastLogin = os.time(),

function DataService:KnitInit()        },

    print("[DataService] Initializing with ProfileService...")        settings = {},

            

    -- Create ProfileStore        -- Metadata

    self._profileStore = ProfileService.GetProfileStore(        dataVersion = DATA_VERSION,

        "PlayerData_v2", -- Store name (change version to reset all data)        createdAt = os.time(),

        ProfileTemplate        lastSaved = os.time(),

    )        

            -- Session data (not saved, managed separately)

    print("[DataService] ProfileStore created successfully")        _sessionId = nil,

end        _sessionLocked = false,

    }

---end

-- Start DataService

-- ProfileService handles auto-save automatically (every 30s by default)---

-- We just need to handle game shutdown-- Migrate old data to new version

---- @param data table - The old data structure

function DataService:KnitStart()-- @return table - Migrated data

    print("[DataService] Starting...")--

    local function migrateData(data)

    -- ProfileService auto-saves every 30 seconds automatically    if not data.dataVersion then

    -- No manual save loop needed!        -- Version 1 â†’ 2: Add new fields

            data.stats = data.stats or {}

    print("[DataService] Started! ProfileService will auto-save profiles.")        data.stats.lastLogin = os.time()

end        data.createdAt = data.createdAt or os.time()

        data.lastSaved = os.time()

---        data.dataVersion = DATA_VERSION

-- Load player profile using ProfileService        print("[DataService] Migrated data from version 1 to", DATA_VERSION)

-- Handles session-locking, reconciliation, and release listening    end

-- @param player Player - The player to load profile for    

-- @return table? - The loaded profile or nil if failed    -- Future migrations go here

--    -- if data.dataVersion == 2 then ... end

function DataService:LoadPlayerData(player: Player)    

    local userId = player.UserId    return data

    local profileKey = "Player_" .. userIdend

    

    print("[DataService] Loading profile for", player.Name)---

    -- Generate unique session ID for this server instance

    -- Load profile (ProfileService handles session-locking)-- @param userId number - The user ID

    local profile = self._profileStore:LoadProfileAsync(profileKey)-- @return string - Unique session identifier

    --

    if profile ~= nil thenlocal function generateSessionId(userId: number)

        -- GDPR compliance - track which user this data belongs to    local jobId = game.JobId

        profile:AddUserId(userId)    if RunService:IsStudio() then

                jobId = "Studio_" .. math.random(100000, 999999)

        -- Fill in missing variables from ProfileTemplate    end

        -- This handles data migration automatically!    return string.format("%s_%d_%d", jobId, userId, os.time())

        profile:Reconcile()end

        

        -- Listen for profile release (when another server steals the profile)---

        profile:ListenToRelease(function()-- Initialize DataService

            self._profiles[player] = nil-- Connects to DataStore or warns if unavailable

            print("[DataService] Profile released for", player.Name)--

            -- Kick player since their profile was stolenfunction DataService:KnitInit()

            player:Kick("Your profile was loaded on another server.")    print("[DataService] Initializing...")

        end)    

            -- Get DataStore

        -- Check if player is still in game    local success, result = pcall(function()

        if player:IsDescendantOf(Players) then        return DataStoreService:GetDataStore("PlayerData_v1")

            -- Store profile    end)

            self._profiles[player] = profile    

                if success then

            -- Initialize/update session data        self._playerDataStore = result

            profile.Data.userId = userId        print("[DataService] DataStore connected successfully")

            profile.Data.planet.userId = userId    else

            profile.Data.stats.sessionStartTime = os.time()        warn("[DataService] Failed to connect to DataStore:", result)

            profile.Data.stats.lastLogin = os.time()        warn("[DataService] Data will NOT be saved!")

            profile.Data.stats.loginCount = (profile.Data.stats.loginCount or 0) + 1    end

            end

            print("[DataService] Successfully loaded profile for", player.Name)

            print("[DataService] Login count:", profile.Data.stats.loginCount)---

            -- Start DataService

            return profile.Data-- Begins auto-save loop and binds to game close event

        else-- Uses Constants.GAMEPLAY.AUTO_SAVE_INTERVAL for timing

            -- Player left before profile loaded--

            profile:Release()function DataService:KnitStart()

            print("[DataService] Player left before profile loaded:", player.Name)    print("[DataService] Starting...")

            return nil    

        end    -- Auto-save loop (managed by Janitor)

    else    local autoSaveThread = task.spawn(function()

        -- Profile couldn't be loaded (session-locked by another server)        while true do

        warn("[DataService] Failed to load profile for", player.Name)            task.wait(Constants.GAMEPLAY.AUTO_SAVE_INTERVAL)

        player:Kick("Failed to load your data. Please try again in a moment.")            self:SaveAllPlayers()

        return nil        end

    end    end)

end    self._janitor:Add(function()

        task.cancel(autoSaveThread)

---    end, true)

-- Save player profile manually    

-- (ProfileService auto-saves, but this allows manual saves)    -- Save all players on game shutdown

-- @param player Player - The player to save    game:BindToClose(function()

-- @return boolean - True if successful        print("[DataService] Game closing, saving all player data...")

--        self:SaveAllPlayers()

function DataService:SavePlayerData(player: Player)        task.wait(3) -- Give time for saves to complete

    local profile = self._profiles[player]    end)

        

    if not profile then    print("[DataService] Started! Auto-save interval:", Constants.GAMEPLAY.AUTO_SAVE_INTERVAL, "seconds")

        warn("[DataService] No profile to save for", player.Name)end

        return false

    end---

    -- Load player data with session-locking

    -- Update play time-- Uses UpdateAsync to atomically claim the session

    if profile.Data.stats and profile.Data.stats.sessionStartTime then-- Retries if session is locked by another server

        local sessionTime = os.time() - profile.Data.stats.sessionStartTime-- @param player Player - The player to load data for

        profile.Data.stats.totalPlayTime = (profile.Data.stats.totalPlayTime or 0) + sessionTime-- @return table? - The loaded player data or nil if failed

        profile.Data.stats.sessionStartTime = os.time()--

    endfunction DataService:LoadPlayerData(player: Player)

        if not self._playerDataStore then

    profile.Data.lastSaved = os.time()        warn("[DataService] DataStore not available, using default data")

            local defaultData = getDefaultData(player.UserId)

    -- ProfileService auto-saves, but we can force a save        self._playerData[player.UserId] = defaultData

    -- Note: ProfileService doesn't have a manual Save() method        return defaultData

    -- It saves automatically every 30 seconds and on Release()    end

        

    print("[DataService] Profile will be saved by ProfileService for", player.Name)    local userId = player.UserId

    return true    local sessionId = generateSessionId(userId)

end    local key = "Player_" .. userId

    

---    print("[DataService] Loading data for", player.Name, "with session", sessionId)

-- Save all active player profiles    

-- Called on game shutdown    -- Attempt to load with session-locking (with retries)

-- @return number - Count of profiles saved    for attempt = 1, self._maxRetries do

--        local success, result = pcall(function()

function DataService:SaveAllPlayers()            return self._playerDataStore:UpdateAsync(key, function(oldData)

    print("[DataService] Releasing all profiles for save...")                -- First time player or no data

    local count = 0                if not oldData then

                        local newData = getDefaultData(userId)

    for player, profile in pairs(self._profiles) do                    newData._sessionId = sessionId

        if profile then                    newData._sessionLocked = true

            -- Update session time before release                    return newData

            if profile.Data.stats and profile.Data.stats.sessionStartTime then                end

                local sessionTime = os.time() - profile.Data.stats.sessionStartTime                

                profile.Data.stats.totalPlayTime = (profile.Data.stats.totalPlayTime or 0) + sessionTime                -- Check if session is locked by another server

            end                if oldData._sessionLocked and oldData._sessionId ~= sessionId then

                                -- Check if session is stale (>10 minutes old)

            profile.Data.lastSaved = os.time()                    local sessionAge = os.time() - (oldData.lastSaved or 0)

            count = count + 1                    if sessionAge < 600 then -- 10 minutes

        end                        warn("[DataService] Session locked by another server for", player.Name)

    end                        return nil -- Cancel update, retry

                        else

    -- ProfileService will auto-save on Release()                        warn("[DataService] Stale session detected, forcing takeover for", player.Name)

    print("[DataService] Prepared", count, "profiles for save")                    end

    return count                end

end                

                -- Claim the session

---                oldData._sessionId = sessionId

-- Get player profile data                oldData._sessionLocked = true

-- @param userId number - The user ID                

-- @return table? - The profile data or nil                -- Migrate data if needed

--                oldData = migrateData(oldData)

function DataService:GetPlayerData(userId: number)                

    local player = Players:GetPlayerByUserId(userId)                -- Merge with defaults (for new fields)

    if not player then                local defaultData = getDefaultData(userId)

        return nil                for key, value in pairs(oldData) do

    end                    defaultData[key] = value

                    end

    local profile = self._profiles[player]                

    if profile then                return defaultData

        return profile.Data            end)

    end        end)

            

    return nil        if success and result then

end            -- Successfully loaded and locked session

            self._playerData[userId] = result

---            self._sessionIds[userId] = sessionId

-- Get player profile (full profile object, not just data)            self._activeSessions[userId] = true

-- @param player Player - The player instance            

-- @return Profile? - The ProfileService profile or nil            -- Update session start time

--            if result.stats then

function DataService:GetProfile(player: Player)                result.stats.sessionStartTime = os.time()

    return self._profiles[player]                result.stats.lastLogin = os.time()

end            end

            

---            print("[DataService] Successfully loaded data for", player.Name)

-- Update player data            return result

-- @param userId number - The user ID        elseif success and not result then

-- @param dataUpdates table - Key-value pairs to update            -- Session locked, retry

-- @return boolean - True if successful            warn("[DataService] Attempt", attempt, "- Session locked for", player.Name, "- Retrying...")

--            task.wait(self._retryDelay * attempt)

function DataService:UpdatePlayerData(userId: number, dataUpdates)        else

    local player = Players:GetPlayerByUserId(userId)            -- Error occurred

    if not player then            warn("[DataService] Error loading data for", player.Name, ":", result)

        warn("[DataService] Player not found for userId:", userId)            task.wait(self._retryDelay)

        return false        end

    end    end

        

    local profile = self._profiles[player]    -- Failed to load after retries

    if not profile then    warn("[DataService] Failed to load data for", player.Name, "after", self._maxRetries, "attempts")

        warn("[DataService] No profile loaded for", player.Name)    warn("[DataService] Kicking player to prevent data loss")

        return false    player:Kick("Failed to load your data. Please rejoin.")

    end    return nil

    end

    -- Update data

    for key, value in pairs(dataUpdates) do---

        profile.Data[key] = value-- Save player data to DataStore

    end-- Updates play time statistics before saving

    -- @param player Player - The player to save data for

    -- ProfileService will auto-save the changes-- @return boolean - True if save succeeded, false otherwise

    return true--

end-- Save player data

function DataService:SavePlayerData(player: Player)

---    local userId = player.UserId

-- Release player profile when they leave    local data = self._playerData[userId]

-- @param player Player - The player leaving    

--    if not data then

function DataService:UnloadPlayerData(player: Player)        warn("[DataService] No data to save for", player.Name)

    local profile = self._profiles[player]        return false

        end

    if profile then    

        -- Update final session time    if not self._playerDataStore then

        if profile.Data.stats and profile.Data.stats.sessionStartTime then        warn("[DataService] DataStore not available, cannot save")

            local sessionTime = os.time() - profile.Data.stats.sessionStartTime        return false

            profile.Data.stats.totalPlayTime = (profile.Data.stats.totalPlayTime or 0) + sessionTime    end

        end    

            -- Update play time

        profile.Data.lastSaved = os.time()    if data.stats and data.stats.sessionStartTime then

                local sessionTime = os.time() - data.stats.sessionStartTime

        -- Release profile (saves and unlocks session)        data.stats.totalPlayTime = (data.stats.totalPlayTime or 0) + sessionTime

        profile:Release()        data.stats.sessionStartTime = os.time()

        self._profiles[player] = nil    end

            

        print("[DataService] Released profile for", player.Name)    local success, errorMsg = pcall(function()

    end        self._playerDataStore:SetAsync("Player_" .. userId, data)

end    end)

    

return DataService    if success then

        print("[DataService] Saved data for", player.Name)
        return true
    else
        warn("[DataService] Failed to save data for", player.Name, ":", errorMsg)
        return false
    end
end

---
-- Save all active players' data
-- Called by auto-save loop and on game shutdown
-- @return number - Count of successfully saved players
--
-- Save all players
function DataService:SaveAllPlayers()
    print("[DataService] Auto-saving all players...")
    local count = 0
    
    for userId, data in pairs(self._playerData) do
        local player = Players:GetPlayerByUserId(userId)
        if player then
            if self:SavePlayerData(player) then
                count = count + 1
            end
        end
    end
    
    print("[DataService] Auto-save complete. Saved", count, "players")
end

---
-- Get player data from cache
-- @param userId number - The user ID
-- @return table? - The cached player data or nil
--
-- Get player data from cache
function DataService:GetPlayerData(userId: number)
    return self._playerData[userId]
end

---
-- Update player data in cache
-- @param userId number - The user ID
-- @param dataUpdates table - Key-value pairs to update
-- @return boolean - True if update succeeded, false if player not loaded
--
-- Update player data in cache
function DataService:UpdatePlayerData(userId: number, dataUpdates)
    if not self._playerData[userId] then
        warn("[DataService] Cannot update data for user", userId, "- not loaded")
        return false
    end
    
    for key, value in pairs(dataUpdates) do
        self._playerData[userId][key] = value
    end
    
    return true
end

---
-- Remove player data from cache when they leave
-- @param userId number - The user ID to unload
--
-- Remove player from cache (when they leave)
function DataService:UnloadPlayerData(userId: number)
    self._playerData[userId] = nil
end

return DataService
